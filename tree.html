<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘</title>
    <style>
        :root {
            --bg-color: #050a05; /* æ·±å“‘å…‰ç»¿é»‘èƒŒæ™¯ */
            --gold: #D4AF37;
            --red: #8B0000;
        }
        body { margin: 0; overflow: hidden; background-color: var(--bg-color); font-family: 'Segoe UI', sans-serif; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        /* æ‘„åƒå¤´é¢„è§ˆ (å·¦ä¸‹è§’ï¼Œç¨å¾®é€æ˜) */
        #webcam-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid var(--gold);
            border-radius: 10px;
            overflow: hidden;
            opacity: 0.7;
            transform: scaleX(-1); /* é•œåƒ */
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        /* æ“ä½œæŒ‡å¼• */
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--gold);
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--red);
        }
        .key-point { font-weight: bold; color: #fff; }
        /* ä¸Šä¼ æŒ‰é’®ï¼ˆæ‰‹æœºç«¯æ”¾å¤§ä¼˜åŒ–ï¼‰ */
        #upload-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            background: var(--red);
            color: white;
            padding: 12px 24px; /* æ”¾å¤§å†…è¾¹è· */
            border: 1px solid var(--gold);
            border-radius: 24px; /* æ›´åœ†æ¶¦æ˜“ç‚¹å‡» */
            cursor: pointer;
            font-weight: bold;
            font-size: 16px; /* æ”¾å¤§å­—ä½“ */
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 10px var(--red);
        }
        #upload-btn:hover { background: #a00000; box-shadow: 0 0 20px var(--gold); }
        input[type="file"] { display: none; }
        /* Loading */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--gold);
            font-size: 24px;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid var(--gold);
        }
    </style>
    <!-- Import Maps for Three.js and MediaPipe -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <!-- UI Elements -->
    <div id="ui-layer">
        <div id="instructions">
            <h3>ğŸ„ æ‰‹åŠ¿æ§åˆ¶å°</h3>
            <p><span class="key-point">âœŠ æ¡æ‹³:</span> èšåˆæˆåœ£è¯æ ‘</p>
            <p><span class="key-point">ğŸ– å¼ å¼€:</span> æ•£å¼€ / æ—‹è½¬è§†è§’</p>
            <p><span class="key-point">ğŸ‘Œ æåˆ:</span> æŠ“å–å¹¶æ”¾å¤§ç…§ç‰‡</p>
        </div>
        
        <div id="webcam-container">
            <video id="webcam" autoplay playsinline></video>
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡äº‘ç´ æ
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
        <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸3Dåœºæ™¯...<br><span style="font-size:14px; color:#aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    </div>

    <!-- Main Application Script -->
    <script type="module">
        // å¯¼å…¥ä¾èµ–
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®é¡¹ï¼ˆæ‰‹æœºç«¯æ€§èƒ½ä¼˜åŒ–ï¼‰ ---
        const CONFIG = {
            colors: {
                green: 0x2F4F4F, // å“‘å…‰ç»¿
                gold: 0xFFD700,  // é‡‘å±é‡‘
                red: 0x8B0000,   // åœ£è¯çº¢
                white: 0xFFFFFF
            },
            particleCount: 300, // ç²’å­æ•°é‡ï¼ˆæ‰‹æœºç«¯é™ä¸º300ï¼Œæå‡æµç•…åº¦ï¼‰
            treeHeight: 20,     // åœ£è¯æ ‘é«˜åº¦
            treeRadius: 8,
            scatterRadius: 30
        };

        // --- å…¨å±€çŠ¶æ€ ---
        const state = {
            mode: 'TREE', // 'TREE'ï¼ˆèšåˆï¼‰| 'SCATTER'ï¼ˆæ•£å¼€ï¼‰| 'ZOOM'ï¼ˆæ”¾å¤§ç…§ç‰‡ï¼‰
            targetRotation: new THREE.Vector2(0, 0),
            zoomIndex: -1,
            handPresent: false
        };

        // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a05, 0.02); // é›¾åŒ–æ•ˆæœ

        // ç›¸æœº
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 40);

        // æ¸²æŸ“å™¨ï¼ˆé€‚é…æ‰‹æœºï¼‰
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒ
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(CONFIG.colors.gold, 500);
        spotLight.position.set(20, 50, 20);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);
        const redLight = new THREE.PointLight(CONFIG.colors.red, 200, 50);
        redLight.position.set(-10, 10, 10);
        scene.add(redLight);

        // åæœŸå¤„ç†ï¼ˆè¾‰å…‰æ•ˆæœï¼‰
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 2. 3Då¯¹è±¡ç®¡ç†ï¼ˆç²’å­+ç…§ç‰‡ï¼‰ ---
        const objects = []; // æ‰€æœ‰äº¤äº’å¯¹è±¡
        const photoMeshes = [];
        const textureLoader = new THREE.TextureLoader();

        // æè´¨å®šä¹‰
        const matGold = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, metalness: 0.9, roughness: 0.1 
        });
        const matGreen = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.green, metalness: 0.2, roughness: 0.8 
        });
        const matRed = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.red, metalness: 0.6, roughness: 0.3, emissive: 0x330000 
        });

        // å‡ ä½•å½¢çŠ¶
        const geoSphere = new THREE.SphereGeometry(0.5, 32, 32);
        const geoBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);

        // åˆ›å»ºè£…é¥°ç²’å­
        function createDecorations() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                if (Math.random() < 0.6) { // 60% çƒä½“
                    const mat = Math.random() < 0.3 ? matGold : (Math.random() < 0.6 ? matRed : matGreen);
                    mesh = new THREE.Mesh(geoSphere, mat);
                } else { // 40% ç«‹æ–¹ä½“ï¼ˆç¤¼ç‰©ç›’ï¼‰
                    mesh = new THREE.Mesh(geoBox, Math.random() < 0.5 ? matGold : matRed);
                }

                // åˆå§‹éšæœºä½ç½®
                mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                
                // ç»‘å®šç›®æ ‡ä½ç½®ï¼ˆåœ£è¯æ ‘/æ•£å¼€ï¼‰
                mesh.userData = {
                    id: i,
                    type: 'decoration',
                    posTree: getTreePosition(i, CONFIG.particleCount),
                    posScatter: getScatterPosition(),
                    rotationSpeed: new THREE.Vector3(Math.random()*0.02, Math.random()*0.02, 0)
                };
                scene.add(mesh);
                objects.push(mesh);
            }
        }

        // åˆ›å»ºç…§ç‰‡å ä½ç¬¦
        function createPhotoPlaceholder(imgUrl = null) {
            const geometry = new THREE.PlaneGeometry(3, 4); // ç«–ç‰ˆç…§ç‰‡æ¯”ä¾‹
            let material;

            if (imgUrl) {
                // è‡ªå®šä¹‰ç…§ç‰‡
                const tex = textureLoader.load(imgUrl);
                tex.colorSpace = THREE.SRGBColorSpace;
                material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            } else {
                // é»˜è®¤å ä½å›¾
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 340;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fff'; ctx.fillRect(0,0,256,340);
                ctx.fillStyle = '#ccc'; ctx.fillRect(10,10,236,250);
                ctx.fillStyle = '#000'; ctx.font = '30px Arial'; ctx.fillText('PHOTO', 80, 150);
                const tex = new THREE.CanvasTexture(canvas);
                material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            }

            const mesh = new THREE.Mesh(geometry, material);
            const i = objects.length;
            mesh.userData = {
                type: 'photo',
                posTree: getTreePosition(i, CONFIG.particleCount + 10, true), // åœ£è¯æ ‘å¤–å±‚
                posScatter: getScatterPosition(),
                isZoomed: false
            };
            mesh.position.copy(scatterPos);

            scene.add(mesh);
            objects.push(mesh);
            photoMeshes.push(mesh);
        }

        // è®¡ç®—åœ£è¯æ ‘èºæ—‹ä½ç½®
        function getTreePosition(index, total, isOuter = false) {
            const h = CONFIG.treeHeight;
            const y = (index / total) * h;
            const progress = index / total;
            const r = (1 - progress) * CONFIG.treeRadius + (isOuter ? 2 : 0);
            const angle = index * 137.5 * (Math.PI / 180); // é»„é‡‘è§’

            return new THREE.Vector3(r * Math.cos(angle), y - h/2, r * Math.sin(angle));
        }

        // è®¡ç®—æ•£å¼€çš„çƒå½¢éšæœºä½ç½®
        function getScatterPosition() {
            const v = new THREE.Vector3();
            v.randomDirection().multiplyScalar(Math.random() * CONFIG.scatterRadius + 10);
            return v;
        }

        // åˆå§‹åŒ–åœºæ™¯å¯¹è±¡
        createDecorations();
        for(let k=0; k<5; k++) createPhotoPlaceholder(); // é»˜è®¤5ä¸ªå ä½å›¾

        // ç…§ç‰‡ä¸Šä¼ å¤„ç†
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(files.length > 0) {
                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (event) => createPhotoPlaceholder(event.target.result);
                    reader.readAsDataURL(file);
                });
                state.mode = 'SCATTER'; // ä¸Šä¼ åè‡ªåŠ¨æ•£å¼€
            }
        });

        // --- 3. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        const lerpSpeed = 0.05; // ç¼“åŠ¨é€Ÿåº¦
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // åœºæ™¯æ—‹è½¬ï¼ˆæ‰‹åŠ¿æ§åˆ¶ï¼‰
            if (state.mode === 'SCATTER' && state.handPresent) {
                const sensitivity = 0.02;
                scene.rotation.y += (state.targetRotation.x * sensitivity - scene.rotation.y) * 0.1;
                scene.rotation.x += (state.targetRotation.y * sensitivity - scene.rotation.x) * 0.1;
            } else if (state.mode === 'TREE') {
                // åœ£è¯æ ‘è‡ªåŠ¨ç¼“æ…¢æ—‹è½¬
                scene.rotation.y += 0.005;
                scene.rotation.x *= 0.95;
            }

            // æ›´æ–°æ‰€æœ‰å¯¹è±¡ä½ç½®
            objects.forEach((obj, idx) => {
                let target = new THREE.Vector3();

                // æ ¹æ®çŠ¶æ€é€‰æ‹©ç›®æ ‡ä½ç½®
                if (state.mode === 'TREE') {
                    target.copy(obj.userData.posTree);
                    // å‘¼å¸æ•ˆæœ
                    target.y += Math.sin(clock.getElapsedTime() * 2 + idx) * 0.1;
                } else if (state.mode === 'SCATTER') {
                    target.copy(obj.userData.posScatter);
                    // æ¼‚æµ®æ•ˆæœ
                    target.x += Math.cos(clock.getElapsedTime() + idx) * 0.05;
                    target.y += Math.sin(clock.getElapsedTime() + idx) * 0.05;
                } else if (state.mode === 'ZOOM') {
                    if (obj.userData.type === 'photo' && idx === state.zoomIndex) {
                        // æ”¾å¤§çš„ç…§ç‰‡å›ºå®šåœ¨ç›¸æœºå‰
                        const camDir = new THREE.Vector3(0, 0, -15);
                        camDir.applyQuaternion(camera.quaternion);
                        target.copy(camera.position).add(camDir);
                        obj.lookAt(camera.position);
                        return;
                    } else {
                        // å…¶ä»–å¯¹è±¡åé€€
                        target.copy(obj.userData.posScatter).multiplyScalar(1.5);
                    }
                }

                // ç¼“åŠ¨åˆ°ç›®æ ‡ä½ç½®
                obj.position.lerp(target, lerpSpeed);
                
                // è£…é¥°ç²’å­è‡ªè½¬
                if (obj.userData.type === 'decoration') {
                    obj.rotation.x += obj.userData.rotationSpeed.x;
                    obj.rotation.y += obj.userData.rotationSpeed.y;
                }
            });

            composer.render();
        }

        // --- 4. MediaPipe æ‰‹åŠ¿è¯†åˆ«ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰ ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        // åˆå§‹åŒ–è§†è§‰å¼•æ“
        async function setupVision() {
            try {
                // åŠ è½½MediaPipe WASMæ–‡ä»¶
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                // åˆ›å»ºæ‰‹åŠ¿è¯†åˆ«å™¨ï¼ˆå…³é”®ï¼šæœ¬åœ°æ¨¡å‹è·¯å¾„ï¼Œæ— ç½‘ç»œä¾èµ–ï¼‰
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        // æœ¬åœ°æ¨¡å‹è·¯å¾„ï¼ˆéœ€å’ŒHTMLæ–‡ä»¶åŒç›®å½•ï¼‰
                        modelAssetPath: "./hand_landmarker.task",
                        delegate: "CPU" // æ‰‹æœºGPUå…¼å®¹ä¼˜å…ˆç”¨CPU
                    },
                    runningMode: "VIDEO",
                    numHands: 1 // åªè¯†åˆ«ä¸€åªæ‰‹
                });

                // åˆå§‹åŒ–æ‘„åƒå¤´ï¼ˆæ‰‹æœºç«¯åˆ†è¾¨ç‡çº¦æŸï¼‰
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640, max: 640 }, // é™åˆ¶åˆ†è¾¨ç‡ï¼Œé™ä½å‹åŠ›
                            height: { ideal: 480, max: 480 },
                            facingMode: "user" // ä¼˜å…ˆå‰ç½®æ‘„åƒå¤´
                        }
                    });
                    webcam.srcObject = stream;
                    // åŒäº‹ä»¶ç›‘å¬ï¼Œé¿å…åŠ è½½å¡ä½
                    webcam.addEventListener("loadeddata", predictWebcam);
                    webcam.addEventListener("play", predictWebcam);
                    document.getElementById('loading').style.display = 'none';
                } else {
                    throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œè¯·å‡çº§è‡³æœ€æ–°ç‰ˆChrome/Safari");
                }
            } catch (error) {
                // é”™è¯¯æç¤ºï¼ˆæ‰‹æœºç«¯å¯è§ï¼‰
                console.error("åˆå§‹åŒ–å¤±è´¥ï¼š", error);
                const loadingEl = document.getElementById('loading');
                loadingEl.innerText = "åˆå§‹åŒ–å¤±è´¥ï¼š" + error.message;
                loadingEl.style.color = "#ff4444";
            }
        }

        // å®æ—¶æ‰‹åŠ¿æ£€æµ‹
        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime) {
                lastVideoTime = webcam.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(webcam, startTimeMs);
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // æ‰‹åŠ¿è§£æï¼ˆæ‰‹æœºç«¯é˜ˆå€¼ä¼˜åŒ–ï¼‰
        function processGestures(result) {
            if (result.landmarks.length > 0) {
                state.handPresent = true;
                const lm = result.landmarks[0]; // ç¬¬ä¸€åªæ‰‹çš„å…³é”®ç‚¹

                // å…³é”®ç‚¹ä½
                const wrist = lm[0];
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const middleTip = lm[12];
                const ringTip = lm[16];
                const pinkyTip = lm[20];

                // 1. æåˆæ£€æµ‹ï¼ˆæ‹‡æŒ‡+é£ŸæŒ‡ï¼‰
                const pinchDist = dist(thumbTip, indexTip);
                const isPinch = pinchDist < 0.08; // æ‰‹æœºç«¯è°ƒå¤§é˜ˆå€¼ï¼Œæ›´æ˜“è¯†åˆ«

                // 2. æ¡æ‹³/å¼ å¼€æ£€æµ‹ï¼ˆæŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»ï¼‰
                const tips = [indexTip, middleTip, ringTip, pinkyTip];
                let avgDistToWrist = 0;
                tips.forEach(tip => avgDistToWrist += dist(tip, wrist));
                avgDistToWrist /= 4;
                const isFist = avgDistToWrist < 0.2;   // æ¡æ‹³
                const isOpen = avgDistToWrist > 0.25;  // å¼ å¼€æ‰‹

                // 3. æ‰‹åŠ¿ä½ç½®æ˜ å°„ï¼ˆæ§åˆ¶æ—‹è½¬ï¼‰
                const handX = (lm[9].x - 0.5) * 2; 
                const handY = (lm[9].y - 0.5) * 2;

                // çŠ¶æ€åˆ‡æ¢é€»è¾‘
                if (isPinch) {
                    // æåˆï¼šæ”¾å¤§ç…§ç‰‡
                    if (state.mode !== 'ZOOM') {
                        state.mode = 'ZOOM';
                        const validPhotos = objects.map((o, i) => o.userData.type === 'photo' ? i : -1).filter(i => i !== -1);
                        if(validPhotos.length > 0) {
                            state.zoomIndex = validPhotos[Math.floor(Math.random() * validPhotos.length)];
                        }
                    }
                } else if (isFist) {
                    // æ¡æ‹³ï¼šèšåˆä¸ºåœ£è¯æ ‘
                    state.mode = 'TREE';
                    state.zoomIndex = -1;
                } else if (isOpen) {
                    // å¼ å¼€æ‰‹ï¼šæ•£å¼€/æ—‹è½¬
                    if (state.mode === 'ZOOM') {
                        state.mode = 'SCATTER';
                        state.zoomIndex = -1;
                    } else {
                        state.mode = 'SCATTER';
                        state.targetRotation.set(handX * 5, handY * 5);
                    }
                }
            } else {
                state.handPresent = false;
            }
        }

        // è®¡ç®—ä¸¤ç‚¹è·ç¦»
        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // çª—å£é€‚é…
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // å¯åŠ¨ç¨‹åº
        setupVision();
        animate();
    </script>
</body>
</html>
