<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>豪华圣诞树（手势控制版）</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: #2b3b35; /* 亮背景，清晰显示 */
        }
        #camera {
            position: absolute;
            top: 0; right: 0;
            width: 120px; height: 160px;
            transform: scaleX(-1); /* 镜像摄像头 */
            border: 2px solid #FFD700;
            border-radius: 8px;
            z-index: 998;
            opacity: 0.7;
        }
        #letter {
            position: absolute;
            top: 50%; left: 20px;
            transform: translateY(-50%);
            width: 180px;
            padding: 20px;
            background: #fff;
            border: 3px solid #FFD700;
            border-radius: 10px;
            font-size: 20px;
            text-align: center;
            color: #c70039;
            font-weight: bold;
            display: none;
            z-index: 997;
            box-shadow: 0 0 20px #FFD700;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 20px;
            z-index: 999;
        }
    </style>
    <!-- 基础Three.js（手机兼容版） -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe手势识别（轻量级） -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
    <div id="loading">初始化手势识别...</div>
    <video id="camera" autoplay muted playsinline></video>
    <div id="letter">圣诞节快乐</div>

    <script>
        // 全局状态（手势控制核心）
        const gestureState = {
            fingerCount: 0,       // 竖起的手指数量
            isPinch: false,        // 是否张合（缩放用）
            isLightOn: false,      // 彩灯是否开启
            isSnowing: false,      // 下雪是否开启
            isMusicPlayed: false,  // 音乐是否播放过（仅播放一次）
            isLetterShow: false    // 信件是否显示
        };

        // 圣诞树配置
        const CONFIG = {
            gold: 0xFFD700, green: 0x2F4F4F, starColor: 0xFFFF00,
            particleCount: 80, starSize: 2.5, treeScale: 1.0
        };

        // 全局3D对象
        let scene, camera, renderer, star, treeGroup, lights, snowParticles = [];
        let musicAudio = null;

        // --------------------------
        // 第一步：初始化3D场景（保底可见）
        // --------------------------
        function initScene() {
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2b3b35);

            // 相机（强制居中可见）
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 25);
            camera.lookAt(0, 0, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);
            document.body.appendChild(renderer.domElement);

            // 灯光（基础照明）
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            const dirLight = new THREE.DirectionalLight(CONFIG.gold, 1.5);
            dirLight.position.set(10, 15, 10);
            scene.add(ambient, dirLight);

            // 创建圣诞树组（方便缩放）
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // 创建金色金属球粒子
            createTreeParticles();
            // 创建立体星星
            createStar();
            // 初始化彩灯（默认隐藏）
            initLights();
            // 初始化雪花（默认隐藏）
            initSnow();

            // 隐藏加载提示
            document.getElementById('loading').style.display = 'none';
        }

        // --------------------------
        // 第二步：创建豪华圣诞树元素
        // --------------------------
        // 1. 金色金属球粒子
        function createTreeParticles() {
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.gold, metalness: 0.95, roughness: 0.05,
                emissive: 0x221100, emissiveIntensity: 0.3
            });
            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.green, metalness: 0.7, roughness: 0.1
            });
            const geo = new THREE.SphereGeometry(0.7, 8, 8);

            for (let i=0; i<CONFIG.particleCount; i++) {
                const mat = i%4 === 0 ? goldMat : greenMat;
                const mesh = new THREE.Mesh(geo, mat);
                const y = (i/CONFIG.particleCount)*15 - 7.5;
                const r = (1 - i/CONFIG.particleCount)*6;
                const angle = i * 137.5 * Math.PI/180;
                mesh.position.set(r*Math.cos(angle), y, r*Math.sin(angle));
                treeGroup.add(mesh);
            }
        }

        // 2. 立体发光星星
        function createStar() {
            const geo = new THREE.OctahedronGeometry(CONFIG.starSize, 0);
            const mat = new THREE.MeshBasicMaterial({
                color: CONFIG.starColor, emissive: CONFIG.starColor, emissiveIntensity: 2.0
            });
            star = new THREE.Group();
            const s1 = new THREE.Mesh(geo, mat); s1.rotation.x = Math.PI/4;
            const s2 = new THREE.Mesh(geo, mat); s2.rotation.y = Math.PI/4;
            star.add(s1, s2);
            star.position.set(0, 8, 0);
            treeGroup.add(star);
        }

        // 3. 螺旋彩灯（1指触发）
        function initLights() {
            lights = new THREE.Group();
            const lightGeo = new THREE.SphereGeometry(0.3, 6, 6);
            // 彩虹色材质
            const colors = [0xff0000, 0xff9900, 0xffff00, 0x00ff00, 0x0099ff, 0x9900ff];
            
            // 螺旋轨迹
            for (let i=0; i<100; i++) {
                const angle = i * 0.2;
                const r = 8 + i * 0.1;
                const y = i * 0.2 - 10;
                const mat = new THREE.MeshBasicMaterial({ color: colors[i%colors.length], emissive: colors[i%colors.length] });
                const light = new THREE.Mesh(lightGeo, mat);
                light.position.set(r*Math.cos(angle), y, r*Math.sin(angle));
                light.visible = false; // 默认隐藏
                lights.add(light);
            }
            treeGroup.add(lights);
        }

        // 4. 雪花粒子（剪刀手触发）
        function initSnow() {
            const snowGeo = new THREE.SphereGeometry(0.2, 4, 4);
            const snowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i=0; i<150; i++) {
                const snow = new THREE.Mesh(snowGeo, snowMat);
                snow.position.set(
                    (Math.random()-0.5)*40,
                    Math.random()*30,
                    (Math.random()-0.5)*40
                );
                snow.visible = false;
                snowParticles.push(snow);
                scene.add(snow);
            }
        }

        // --------------------------
        // 第三步：手势识别核心逻辑
        // --------------------------
        function initHandTracking() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            // 配置手势识别
            hands.setOptions({
                maxNumHands: 1, // 仅识别单手
                modelComplexity: 0, // 低复杂度，适配手机
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            // 手势解析
            hands.onResults((results) => {
                if (!results.multiHandLandmarks) {
                    gestureState.fingerCount = 0;
                    gestureState.isPinch = false;
                    return;
                }

                // 解析单手指数量
                const landmarks = results.multiHandLandmarks[0];
                gestureState.fingerCount = countFingers(landmarks);
                // 解析手掌张合（缩放用）
                gestureState.isPinch = checkPinch(landmarks);

                // 执行手势指令
                executeGestureCommand();
            });

            // 启动摄像头
            const camera = new Camera(document.getElementById('camera'), {
                onFrame: async () => await hands.send({ image: document.getElementById('camera') }),
                width: 120,
                height: 160
            });
            camera.start();
        }

        // 统计竖起的手指数量
        function countFingers(landmarks) {
            let count = 0;
            // 指尖关键点索引：拇指4、食指8、中指12、无名指16、小指20
            const fingerTips = [4,8,12,16,20];
            const fingerBases = [2,5,9,13,17];

            // 拇指判断（特殊逻辑）
            if (landmarks[4].x < landmarks[3].x) count++;
            // 其他手指（指尖y坐标 < 指节y坐标 即为竖起）
            for (let i=1; i<5; i++) {
                if (landmarks[fingerTips[i]].y < landmarks[fingerBases[i]].y) count++;
            }
            return count;
        }

        // 检测手掌张合（缩放）
        function checkPinch(landmarks) {
            // 计算拇指尖(4)和食指尖(8)的距离
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            // 距离<0.05为握拳（缩小），>0.1为张开（放大）
            CONFIG.treeScale = distance < 0.05 ? Math.max(0.5, CONFIG.treeScale - 0.01) : Math.min(1.5, CONFIG.treeScale + 0.01);
            treeGroup.scale.set(CONFIG.treeScale, CONFIG.treeScale, CONFIG.treeScale);
            return distance < 0.08;
        }

        // 执行手势指令
        function executeGestureCommand() {
            const letter = document.getElementById('letter');
            // 1指：点亮彩灯
            if (gestureState.fingerCount === 1) {
                gestureState.isLightOn = true;
                lights.children.forEach(light => light.visible = true);
            }
            // 2指：开始下雪
            if (gestureState.fingerCount === 2) {
                gestureState.isSnowing = true;
                snowParticles.forEach(snow => snow.visible = true);
            }
            // 3指：播放音乐（仅播放一次）
            if (gestureState.fingerCount === 3 && !gestureState.isMusicPlayed) {
                gestureState.isMusicPlayed = true;
                playChristmasMusic();
            }
            // 4指：显示信件
            if (gestureState.fingerCount === 4) {
                gestureState.isLetterShow = true;
                letter.style.display = 'block';
            }
            // 握拳（0指）：关闭信件
            if (gestureState.fingerCount === 0) {
                gestureState.isLetterShow = false;
                letter.style.display = 'none';
            }
        }

        // 播放圣诞音乐
        function playChristmasMusic() {
            // 使用免费圣诞音乐CDN
            musicAudio = new Audio('https://cdn.jsdelivr.net/gh/holiday-projects/christmas-music/merry-christmas.mp3');
            musicAudio.loop = true; // 循环播放
            musicAudio.volume = 0.5;
            musicAudio.play().catch(e => {
                // 需用户交互触发，提示点击播放
                alert('请点击屏幕授权播放音乐');
                document.body.addEventListener('click', () => musicAudio.play(), { once: true });
            });
        }

        // --------------------------
        // 第四步：动画循环
        // --------------------------
        function animate() {
            requestAnimationFrame(animate);

            // 星星旋转
            if (star) star.rotation.x += 0.01;

            // 雪花飘落动画
            if (gestureState.isSnowing) {
                snowParticles.forEach(snow => {
                    snow.position.y -= 0.05;
                    snow.position.x += (Math.random()-0.5)*0.02;
                    // 雪花落地重置
                    if (snow.position.y < -10) snow.position.y = 30;
                });
            }

            // 渲染场景
            renderer.render(scene, camera);
        }

        // --------------------------
        // 启动流程（容错）
        // --------------------------
        try {
            initScene();          // 初始化3D场景
            initHandTracking();   // 初始化手势识别
            animate();            // 启动动画
        } catch (e) {
            document.getElementById('loading').innerHTML = `初始化失败：${e.message}<br>请刷新重试`;
            document.getElementById('loading').style.color = '#ff0000';
        }

        // 窗口适配
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
